module mojo_top (
    input clk,
    input rst_n, // reset button (active low)
    output pina[12], // for led matrix
    output pinb[12], // for led matrix
    input pinc[4], // for keypad, 4 pins on the left
    output pind[4], // for keypad, 4 pins on the right
    
    output led[8]
) {
    sig mask[12][12];
    sig rst;
    sig game_possibilties[3][12];
    sig hint_possibilties[3][12];

    board_updater my_updater;
    led_matrix_controller my_led;
    keypad_controller my_keypad;

    .clk(clk) {
        reset_conditioner reset_cond;
        .rst(rst) {
            fsm state = {INIT, PLAY, FIN};
            counter ctr (#SIZE(6),#TOP(63),#DIV(12));
            counter ktr (#SIZE(2), #DIV(24));
            counter clock (#SIZE(6), #TOP(40), #DIV(26));
            dff game[12](.clk(clk), .rst(rst));
            dff hint[12](.clk(clk), .rst(rst));
            dff move[8](.clk(clk), .rst(rst));
            dff step[6](.clk(clk), .rst(rst));
            dff init_game[12](.clk(clk), .rst(rst));
            dff inti_hint[12](.clk(clk), .rst(rst));
            dff count_for_init[3](.clk(clk), .rst(rst));
        }
    }


    always {
        led = 8b00110000;

        reset_cond.in = ~rst_n; // input raw inverted reset signal
        rst = reset_cond.out;   // conditioned reset
    
        // update for initial game and hint set, currently not used, perhaps implemented later.
        game_possibilties[0] = 12b010011111110;
        game_possibilties[1] = 12b110010000001;
        game_possibilties[2] = 12b101000100111;
    
        hint_possibilties[0] = 12b100110111110;
        hint_possibilties[1] = 12b011001010011;
        hint_possibilties[2] = 12b101100101110;

        count_for_init.d = 0;
        init_game.d = 12b010011111110;
        inti_hint.d = 12b100110111110;
    
        mask[0] = 12b110010000000;
        mask[1] = 12b111001000000;
        mask[2] = 12b011100100000;
        mask[3] = 12b001100010000;
        mask[4] = 12b100011001000;
        mask[5] = 12b010011100100;
        mask[6] = 12b001001110010;
        mask[7] = 12b000100110001;
        mask[8] = 12b000010001100;
        mask[9] = 12b000001001110;
        mask[10] = 12b000000100111;
        mask[11] = 12b000000010011;

        // stupid code, exclusively for retarded Mojo
        my_updater.mask = mask;
        my_updater.hint = hint.q;
        my_updater.move = move.q;
        my_updater.game = game.q;
        pina = 0;
        pinb = 0;
        pind = 0;
    
        // update my_keypad
        my_keypad.pin = pinc;
        my_keypad.ind = ktr.value;
        pind = my_keypad.pinr;

    
        // update my_led
        // DEBUG: indices
        my_led.game[2] = game.q[11:8];
        my_led.game[1] = game.q[7:4];
        my_led.game[0] = game.q[3:0];
        my_led.hint[2] = hint.q[11:8];
        my_led.hint[1] = hint.q[7:4];
        my_led.hint[0] = hint.q[3:0];
        my_led.step = step.q;
        my_led.ind = ctr.value;
        my_led.smile = 0;    
    
        case (state.q) {
            state.INIT:
                led = 8b10101010;
                game.d = init_game.q;
                hint.d = inti_hint.q;
                move.d = 42;
                step.d = 0;
                my_led.show_hint = 0;

                if (my_keypad.move != 42){
                    state.d = state.PLAY;
                }
                my_led.show_hint = 0;
        

      
             state.PLAY:
                led = move.q;
                   // game.d = game.q ^ mask[0];
                    //hint.d = hint.q ^ 12b000000000001;
                move.d = my_keypad.move;
                    //my_updater.hint = hint.q;
                    //my_updater.game = game.q;
                step.d = clock.value;
                game.d = my_updater.new_game;
                hint.d = my_updater.new_hint;
                if (move.q == 42){led = 8b10000000;}
                
                // display all the stuff
                pina = my_led.pina;
                pinb = my_led.pinb;

                // see if game is solved
                if (game.q == 0) {
                    state.d = state.FIN;
                }
                
                // see if player gave up
                if (my_keypad.restart_game == 1) {
                    state.d = state.INIT;
                }
        
                // see if we want to show smile
                if (my_keypad.show_smile == 1) {
                    state.d = state.FIN;
                }
        
                if (my_keypad.show_hint == 1) {
                    if (my_led.showing_hint == 1) {
                        my_led.show_hint = 0;
                    } else {
                        my_led.show_hint = 1;
                    }
                }

                
        state.FIN:
                led = my_keypad.move;
                // waiting for restart
        
                my_led.smile = 1 ;
        
                count_for_init.d = (count_for_init.q + 1) - (count_for_init.q / 3) * 3;
                init_game.d = game_possibilties[count_for_init.q];
                inti_hint.d = hint_possibilties[count_for_init.q];
                
                if (my_keypad.restart_game == 1) {
                   state.d = state.INIT;
                }
        
      }

        pina = my_led.pina;
        pinb = my_led.pinb;
        
        //led = c{my_led.xx, my_led.yy};
    }

 
    }