module mojo_top (
    input clk,
    input rst_n, // reset button (active low)
    output pina[12], // for led matrix
    output pinb[12], // for led matrix
    input pinc[4], // for keypad, 4 pins on the left
    output pind[4] // for keypad, 4 pins on the right
) {

    const INIT_GAME = 12b001001110100;
    const INIT_HINT = 12b011010111001;
    sig mask[12][12];
    sig rst;

    board_updater my_updater;
    led_matrix_controller my_led;
    keypad_controller my_keypad;

    .clk(clk) {
        reset_conditioner reset_cond;
        .rst(rst) {
            fsm state = {INIT, PLAY, FIN};
            counter ctr (#SIZE(6),#TOP(63),#DIV(24));
            counter ktr (#SIZE(2), #TOP(3), #DIV(24));
            dff game[12](.clk(clk), .rst(rst));
            dff hint[12](.clk(clk), .rst(rst));
            dff move(.clk(clk), .rst(rst));
            dff step(.clk(clk), .rst(rst));
        }
    }


    always {

        reset_cond.in = ~rst_n; // input raw inverted reset signal
        rst = reset_cond.out;   // conditioned reset

        mask[0] = 12b110010000000;
        mask[1] = 12b111001000000;
        mask[2] = 12b011100100000;
        mask[3] = 12b001100010000;
        mask[4] = 12b100011001000;
        mask[5] = 12b010011100100;
        mask[6] = 12b001001110010;
        mask[7] = 12b000100110001;
        mask[8] = 12b000010001100;
        mask[9] = 12b000001001110;
        mask[10] = 12b000000100111;
        mask[11] = 12b000000010011;

        // stupid code, exclusively for retarded Mojo
        my_updater.mask = mask;
        my_updater.hint = hint.q;
        my_updater.move = 42;
        my_updater.game = game.q;
        pina = 0;
        pinb = 0;
        pind = 0;
    
        // update my_keypad
        my_keypad.pin = pinc;
        my_keypad.ind = ktr.value;

        // update my_led
        // DEBUG: indices
        my_led.game[0] = game.q[11:8];
        my_led.game[1] = game.q[7:4];
        my_led.game[2] = game.q[3:0];
        my_led.hint[0] = hint.q[11:8];
        my_led.hint[1] = hint.q[7:4];
        my_led.hint[2] = hint.q[3:0];
        my_led.step = step.q;
        my_led.ind = ctr.value;
        my_led.show_hint = my_keypad.show_hint;

        case (state.q) {
            state.INIT:
                // initialize board, hint and step counter
                game.d = INIT_GAME;
                hint.d = INIT_HINT;
                move.d = 42;
                my_updater.hint = INIT_HINT;
                my_updater.move = 42;
                my_updater.game = INIT_GAME;
                step.d = 0;
                state.d = state.PLAY;

            state.PLAY:
                // read move
                move.d = my_keypad.move;

                // update board, hint and step
                step.d = step.q + 1;
                my_updater.hint = hint.q;
                my_updater.move = move.q;
                my_updater.game = game.q;
                game.d = my_updater.new_game;
                hint.d = my_updater.new_hint;

                // display all the stuff
                pina = my_led.pina;
                pinb = my_led.pinb;

                // see if game is solved
                if (my_updater.new_hint == 0) {
                    state.d = state.FIN;
                }
                
                // see if player gave up
                if (my_keypad.restart_game == 1) {
                    state.d = state.INIT;
                }

            state.FIN:
                // waiting for restart
                if (my_keypad.move != 42) {
                    state.d = state.INIT;
                }

                // TODO: display congratulation msg
        
        }

 
    }
  
}
